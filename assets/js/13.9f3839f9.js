(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{443:function(t,a,_){"use strict";_.r(a);var r=_(35),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),_("p",[t._v("基于TCP：TCP是一个端到端的可靠的面向连接的协议，HTTP基于传输层TCP协议不用担心数据传输的问题")]),t._v(" "),_("h2",{attrs:{id:"过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[t._v("#")]),t._v(" 过程")]),t._v(" "),_("p",[t._v("​\t ①对域名进行域名解析，浏览器自身的DNS缓存->系统自身的DNS缓存->hosts->DNS服务器")]),t._v(" "),_("p",[t._v("​     ②根据IP，找到对应的服务器，发起TCP的三次握手建立连接")]),t._v(" "),_("p",[t._v("​     ③建立连接，发起HTTP请求")]),t._v(" "),_("p",[t._v("​     ④服务器响应HTTP请求得到HTML代码")]),t._v(" "),_("p",[t._v("​     ⑤浏览器解析HTML代码，请求代码中的资源")]),t._v(" "),_("p",[t._v("​     ⑥浏览器对页面进行渲染")]),t._v(" "),_("p",[t._v("​     ⑦浏览器关闭，TCP四次挥手断开连接")]),t._v(" "),_("h2",{attrs:{id:"状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),_("p",[_("strong",[t._v("200")]),t._v("：请求已成功，请求所希望的响应头或数据体将随此响应返回。\n400：请求格式错误。")]),t._v(" "),_("ol",[_("li",[t._v("语义有误，当前请求无法被服务器理解。除非进行 修改，否则客户端不应该重\n复提交这个请求；")]),t._v(" "),_("li",[t._v("请求参数有误。")])]),t._v(" "),_("p",[_("strong",[t._v("404")]),t._v("：请求失败，请求所希望得到的资源未被在服务器上发现。\n500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。")]),t._v(" "),_("p",[_("strong",[t._v("100")]),t._v(" =>正在初始化（一般是看不到的）\n101 =>正在切换协议（ websocket 浏览器提供的）\n202 =>表示接受\n"),_("strong",[t._v("301")]),t._v(" =>永久重定向 永久转移\n"),_("strong",[t._v("302")]),t._v(" =>临时重定向 临时转移（一般用来做服务器负载均衡）\n304 =>本次获取的内容是读取缓存中的数据，会每次去服务器校验\n401 =>未认证，没有登录网站\n"),_("strong",[t._v("403")]),t._v(" =>禁止访问，没有权限\n502 =>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求\n"),_("strong",[t._v("503")]),t._v(" =>服务器超负荷（假设一台服务器只能承受 10000 人，当第 10001 人访问的时候，如果服务器没有做负载均衡，那么这个人的网络状态码就是 503\n505 =>服务器不支持请求的 HTTP 协议的版本，无法完成处理。")]),t._v(" "),_("h2",{attrs:{id:"http缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[t._v("#")]),t._v(" HTTP缓存")]),t._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),_("p",[t._v("利用http 的返回头中的 Expires 或者 Cache Control 两个字段来控制的，用来表示资源的缓存时间。")]),t._v(" "),_("h4",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),_("p",[t._v("①缓存过期时间，用于指定资源到期的时间")]),t._v(" "),_("p",[t._v("②是服务器响应消息头字段，在响应http请求时告知浏览器在过期时间前可以从浏览器缓存取数据")]),t._v(" "),_("p",[t._v("③这个时间是一个绝对时间，当客户端本地时间被修改后，服务器与客户端时间偏差变大，就会导致缓存混乱")]),t._v(" "),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache Control")]),t._v(" "),_("p",[t._v("①CacheControl 是一个相对时间，例如 Cache Control:3600 ，代表着资源的有效期是 3600秒。由于是相对时间，并且都是与客户端间比较，所以服务器与客户端时间偏差也不会导致问题。")]),t._v(" "),_("p",[t._v("②CacheControl 与 Expires 同时启用的时候Cache Control 优先级高")]),t._v(" "),_("p",[t._v("③由多个字段组合生成")]),t._v(" "),_("p",[t._v("​\tⅠ、max-age：指定一个时间长度，在这个时间段内是有效的")]),t._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("blockquote",[_("p",[t._v("询问服务器缓存文件是否更新，没有更新就用缓存，更新则向服务器发送请求")])]),t._v(" "),_("p",[t._v("若未命中强缓存，浏览器则会向服务器发起请求，服务器根据http头信息中的Last- Modify/if-Modify-Since或Etag/if-None-Match来判断是否命中协商缓存，命中则返回304，浏览器从缓存中加载资源")]),t._v(" "),_("h4",{attrs:{id:"last-modify-if-modify-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modify-if-modify-since"}},[t._v("#")]),t._v(" Last- Modify/if-Modify-Since")]),t._v(" "),_("p",[t._v("浏览器第一次请求一个资源时，服务器返回的head中会加上Last-Modify，它是一个时间标识，表示该资源的最后修改时间")]),t._v(" "),_("p",[t._v("当浏览器再次请求该资源时，发送的请求头会包含/if-Modify-Since，浏览器根据资源最后修改时间判断是否命中缓存")]),t._v(" "),_("p",[t._v("如果命中缓存，返回304，不会返回资源内容、Last-Modify")]),t._v(" "),_("p",[t._v("但是有时通过最后修改时间来判断资源是否修改还是不太准确，资源变化最后修改时间也可以一致")]),t._v(" "),_("h4",{attrs:{id:"etag-if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" Etag/if-None-Match")]),t._v(" "),_("p",[t._v("Etag/if-None-Match返回的是一个校验码，可以保证每一个资源是唯一的，资源变化会导致ETag变化，ETag值的变更则说明状态已经被修改，服务器根据浏览器上发送的if-None-Match来判断是否命中缓存")]),t._v(" "),_("h2",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("h4",{attrs:{id:"简述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[t._v("#")]),t._v(" 简述")]),t._v(" "),_("p",[t._v("https 并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。")]),t._v(" "),_("h4",{attrs:{id:"组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组成"}},[t._v("#")]),t._v(" 组成")]),t._v(" "),_("p",[t._v("HTTPS 主要由两部分组成：HTTP + SSL / TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。")]),t._v(" "),_("h4",{attrs:{id:"优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[t._v("#")]),t._v(" 优势")]),t._v(" "),_("h5",{attrs:{id:"_1、双向的身份认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、双向的身份认证"}},[t._v("#")]),t._v(" 1、双向的身份认证")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081",target:"_blank",rel:"noopener noreferrer"}},[t._v("客户端"),_("OutboundLink")],1),t._v("和"),_("a",{attrs:{href:"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF/6492316",target:"_blank",rel:"noopener noreferrer"}},[t._v("服务端"),_("OutboundLink")],1),t._v("在传输数据之前,会通过基于"),_("a",{attrs:{href:"https://baike.baidu.com/item/X.509/2817050",target:"_blank",rel:"noopener noreferrer"}},[t._v("X.509"),_("OutboundLink")],1),t._v("证书对双方进行身份认证")]),t._v(" "),_("p",[t._v("①客户端发起 SSL 握手消息给服务端要求连接。")]),t._v(" "),_("p",[t._v("②服务端将证书发送给客户端。")]),t._v(" "),_("p",[t._v("③客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。")]),t._v(" "),_("p",[t._v("④服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的"),_("a",{attrs:{href:"https://baike.baidu.com/item/%E5%85%AC%E9%92%A5/6447788",target:"_blank",rel:"noopener noreferrer"}},[t._v("公钥"),_("OutboundLink")],1),t._v("，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。")]),t._v(" "),_("h5",{attrs:{id:"_2、数据传输的机密性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、数据传输的机密性"}},[t._v("#")]),t._v(" 2、数据传输的机密性")]),t._v(" "),_("p",[t._v("①客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。")]),t._v(" "),_("p",[t._v("②客户端发送协商请求给服务端, 其中包含自己支持的算法以及加密密钥的长度。")]),t._v(" "),_("p",[t._v("③ 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。")]),t._v(" "),_("p",[t._v("④客户端生成随机的字符串，通过协商好的"),_("a",{attrs:{href:"https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/1208652",target:"_blank",rel:"noopener noreferrer"}},[t._v("非对称加密算法"),_("OutboundLink")],1),t._v("，使用服务端的公钥对该字符串进行加密，发送给服务端。")]),t._v(" "),_("p",[t._v("⑤ 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密 。")]),t._v(" "),_("h5",{attrs:{id:"_3、防止重放攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、防止重放攻击"}},[t._v("#")]),t._v(" 3、防止重放攻击")]),t._v(" "),_("p",[t._v("①SSL使用序列号来保护通讯方免受报文重放攻击。")]),t._v(" "),_("p",[t._v("②这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。")]),t._v(" "),_("p",[t._v("③这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。")]),t._v(" "),_("h2",{attrs:{id:"http2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),_("h3",{attrs:{id:"http1-1存在的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-1存在的问题"}},[t._v("#")]),t._v(" HTTP1.1存在的问题")]),t._v(" "),_("h4",{attrs:{id:"_1、tcp-连接数限制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、tcp-连接数限制"}},[t._v("#")]),t._v(" 1、TCP 连接数限制")]),t._v(" "),_("p",[t._v("对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接")]),t._v(" "),_("p",[t._v("​\t\t解决方案：为了解决数量限制，出现了 "),_("code",[t._v("域名分片")]),t._v(" 技术，其实就是资源分域，将资源放在不同域名下")]),t._v(" "),_("p",[t._v("​\t\t弊端：对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等")]),t._v(" "),_("h4",{attrs:{id:"_2、线头阻塞问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、线头阻塞问题"}},[t._v("#")]),t._v(" 2、线头阻塞问题")]),t._v(" "),_("p",[t._v("每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 先进先出 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻")]),t._v(" "),_("p",[t._v("​\t\t解决方案：管线化 技术，"),_("strong",[t._v("将多个 HTTP 请求（request）整批提交")]),t._v("，而在发送过程中不需先等待伺服端的回应。")]),t._v(" "),_("p",[t._v("​\t\t弊端：第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化")]),t._v(" "),_("h4",{attrs:{id:"_3、明文传输不安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、明文传输不安全"}},[t._v("#")]),t._v(" 3、明文传输不安全")]),t._v(" "),_("h4",{attrs:{id:"_4、单个请求内容变大"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、单个请求内容变大"}},[t._v("#")]),t._v(" 4、单个请求内容变大")]),t._v(" "),_("p",[t._v("为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制")]),t._v(" "),_("h3",{attrs:{id:"http2优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2优势"}},[t._v("#")]),t._v(" HTTP2优势")]),t._v(" "),_("h4",{attrs:{id:"_1、二进制分帧层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、二进制分帧层"}},[t._v("#")]),t._v(" 1、二进制分帧层")]),t._v(" "),_("p",[t._v("帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧")]),t._v(" "),_("h5",{attrs:{id:"帧-frame-和流-stream"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#帧-frame-和流-stream"}},[t._v("#")]),t._v(" 帧（frame）和流（stream）")]),t._v(" "),_("ul",[_("li",[t._v("Stream 为 Request/Response 报文的双向通道，一个完整资源的请求与相应是一个 stream，特殊的 stream 作为 Settings、Window_Update 等 Frame 发送的通道")]),t._v(" "),_("li",[t._v("Frame 为 http2 通信的最小单位，有 Data、Headers 等，一个 Stream 包含多个 Frame，如一条 http 请求包含 Header、Data Frame 等")])]),t._v(" "),_("h4",{attrs:{id:"_2、多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、多路复用"}},[t._v("#")]),t._v(" 2、多路复用")]),t._v(" "),_("p",[t._v("在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。 把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。")]),t._v(" "),_("p",[t._v("流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题")]),t._v(" "),_("p",[t._v("所以 http2 对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接:")]),t._v(" "),_("h4",{attrs:{id:"_3、头部压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、头部压缩"}},[t._v("#")]),t._v(" 3、头部压缩")]),t._v(" "),_("p",[t._v("使用 "),_("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fhttpwg.org%2Fspecs%2Frfc7541.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HPACK"),_("OutboundLink")],1),t._v(" 算法来压缩首部内容")]),t._v(" "),_("h4",{attrs:{id:"_4、服务端推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、服务端推送"}},[t._v("#")]),t._v(" 4、服务端推送")]),t._v(" "),_("p",[t._v("浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。")])])}),[],!1,null,null,null);a.default=e.exports}}]);