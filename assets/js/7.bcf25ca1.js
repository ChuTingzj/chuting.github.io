(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{436:function(t,a,v){"use strict";v.r(a);var _=v(35),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),v("h2",{attrs:{id:"渲染过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[t._v("#")]),t._v(" 渲染过程")]),t._v(" "),v("p",[t._v("1、构建DOM树，渲染引擎解析HTML文档，将标签转换为DOM中的DOM节点，生成内容树")]),t._v(" "),v("p",[t._v("2、构建渲染树，解析对应的CSS样式文件，构建渲染树，不包含隐藏的节点")]),t._v(" "),v("p",[t._v("3、布局渲染树，从根节点递归调用，计算每一个元素的大小、位置，给出每一个节点在屏幕上的精确坐标")]),t._v(" "),v("p",[t._v("4、绘制渲染树，遍历渲染树，使用UI层来绘制每个节点")]),t._v(" "),v("h2",{attrs:{id:"垃圾回收机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),v("h3",{attrs:{id:"方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方式"}},[t._v("#")]),t._v(" 方式")]),t._v(" "),v("h4",{attrs:{id:"引用法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用法"}},[t._v("#")]),t._v(" 引用法")]),t._v(" "),v("blockquote",[v("p",[t._v("就是判断一个对象的引用数，引用数"),v("code",[t._v("为0")]),t._v("就回收，引用数"),v("code",[t._v("大于0")]),t._v("就不回收。")])]),t._v(" "),v("p",[t._v("在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引 用计数方式进行垃圾回收。")]),t._v(" "),v("p",[t._v("引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该\n变量的时候这个值的引用次数就加 1 ，如果该变量的值变成了另外一个，则这个值得引用次数\n减 1 ，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此\n可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间")]),t._v(" "),v("p",[t._v("在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过\n引用计数回收垃圾的，也就是说只要涉及 BOM 及 DOM 就 会出现循环引用问题")]),t._v(" "),v("h4",{attrs:{id:"标记法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记法"}},[t._v("#")]),t._v(" 标记法")]),t._v(" "),v("blockquote",[v("p",[t._v("标记法就是，将"),v("code",[t._v("可达")]),t._v("的对象标记起来，"),v("code",[t._v("不可达")]),t._v("的对象当成垃圾回收。")])]),t._v(" "),v("p",[t._v("从初始的"),v("code",[t._v("根对象（window或者global）")]),t._v("的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。")]),t._v(" "),v("p",[t._v("那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。")])])}),[],!1,null,null,null);a.default=r.exports}}]);